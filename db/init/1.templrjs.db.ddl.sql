CREATE TABLE inquiries (id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY, created_at TIMESTAMP(6) WITH TIME ZONE DEFAULT now(), name TEXT NOT NULL, phone_number TEXT, company_name TEXT, inquiry_reason TEXT, description TEXT NOT NULL, tenant TEXT, email TEXT, PRIMARY KEY (id));
COMMENT ON TABLE inquiries IS 'Recordings of anonymous enquires sent thru contact form';

CREATE TABLE navigation
(
    id BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    code character varying,
    parent_code character varying,
    name character varying COLLATE pg_catalog."default" NOT NULL,
    description character varying,
    icon character varying,
    href character varying,
    iconforeground text,
    iconbackground text,
    click_event text,
    tenant_code text,
    is_active boolean DEFAULT true,
    is_action_button boolean DEFAULT false,
    nav_module_code text,
    sort_order smallint,
    is_footer_description boolean DEFAULT false,
    css_class text,
    CONSTRAINT navigation_pkey PRIMARY KEY (id),
    CONSTRAINT navigation_code_navigation_parent_code FOREIGN KEY (parent_code)
        REFERENCES "templrjsDev".navigation (code) MATCH SIMPLE
        ON UPDATE CASCADE
        ON DELETE SET NULL
)

COMMENT ON TABLE navigation IS 'Site navigation persist as parent child relationship using self reference model';

CREATE TABLE properties (code CHARACTER VARYING DEFAULT ''::character varying NOT NULL, name CHARACTER VARYING NOT NULL, parent_code CHARACTER VARYING, description CHARACTER VARYING, additional_attributes JSONB, tenant CHARACTER VARYING, update_count BIGINT, created_by CHARACTER VARYING, updated_by CHARACTER VARYING, created_at TIMESTAMP(6) WITH TIME ZONE DEFAULT now(), updated_at TIMESTAMP(6) WITH TIME ZONE DEFAULT now(), is_active BOOLEAN DEFAULT true, is_archived BOOLEAN DEFAULT false, id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY, PRIMARY KEY (id), CONSTRAINT uc__properties__code__parent_code UNIQUE (code, parent_code));
COMMENT ON TABLE properties IS 'Properties are used to store key value pairs for various purposes i.e. configuration, settings, etc.';

CREATE TABLE 
    company 
    ( 
        id           BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY, 
        code         TEXT NOT NULL, 
        company_name         TEXT, 
        tin_ein_number           TEXT, 
        date_of_incorporation    TIMESTAMP(6) WITH TIME ZONE, 
        country_of_incorporation TEXT, 
        company_website      TEXT, 
        company_email        TEXT, 
        logo_url TEXT,
        phone_number TEXT,
        address JSONB,
        description  TEXT, 
        tenant       TEXT,
        additional_attributes JSONB,
        is_active    BOOLEAN DEFAULT true, 
        is_archived  BOOLEAN DEFAULT false, 
        created_by   TEXT, 
        updated_by   TEXT, 
        created_at   TIMESTAMP(6) WITH TIME ZONE DEFAULT now(), 
        updated_at   TIMESTAMP(6) WITH TIME ZONE DEFAULT now(), 
        update_count BIGINT,  
        PRIMARY KEY (id) 
    );
 
COMMENT ON TABLE company IS 'Company or Organization details including address, contact details, etc.';

CREATE TABLE IF NOT EXISTS country (
  id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY, 
  code char(2) NOT NULL,
  name_caps varchar(80) NOT NULL,
  name varchar(80) NOT NULL,
  iso3 char(3) DEFAULT NULL,
  numcode smallint DEFAULT NULL,
  phonecode int NOT NULL,
  PRIMARY KEY (id)
);

COMMENT ON TABLE country IS 'Master tables for list of countries and their details i.e. name, code, phone code, etc.';

/*Identity column start value*/
SELECT setval(pg_get_serial_sequence('navigation', 'id'),(select max(id) from navigation));
SELECT setval(pg_get_serial_sequence('properties', 'id'), (select max(id) from properties));
SELECT setval(pg_get_serial_sequence('company', 'id'), (select max(id) from company));
SELECT setval(pg_get_serial_sequence('inquiries', 'id'), (select max(id) from inquiries));

/*vw_meta_column*/
CREATE VIEW vw_meta_column (column_name, description, relname) AS  SELECT a.attname AS column_name,
    d.description,
    c.relname
   FROM ((((pg_class c
     JOIN pg_attribute a ON ((c.oid = a.attrelid)))
     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
     LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))
     LEFT JOIN pg_description d ON (((d.objoid = c.oid) AND (d.objsubid = a.attnum))))
  WHERE ((c.relkind = ANY (ARRAY['r'::"char", 'v'::"char"])) AND (c.relname = 'State'::name))
  ORDER BY n.nspname, c.relname, a.attname;

  /*vw_navigation*/
CREATE VIEW vw_navigation (menuitems) AS  WITH RECURSIVE navigation_from_parents AS (
         SELECT navigation.code,
            navigation.name,
            navigation.description,
            navigation.icon,
            navigation.href,
            navigation.click_event,
            navigation.iconforeground,
            navigation.iconbackground,
            '{}'::character varying[] AS parents,
            0 AS level
           FROM navigation
          WHERE (navigation.parent_code IS NULL)
        UNION ALL
         SELECT c.code,
            c.name,
            c.description,
            c.icon,
            c.href,
            c.click_event,
            c.iconforeground,
            c.iconbackground,
            (p.parents || c.parent_code),
            (p.level + 1)
           FROM (navigation_from_parents p
             JOIN navigation c ON (((c.parent_code)::text = (p.code)::text)))
          WHERE (NOT ((c.code)::text = ANY ((p.parents)::text[])))
        ), navigation_from_children AS (
         SELECT c.parent_code,
            (json_agg(jsonb_build_object('code', c.code, 'parent_code', c.parent_code, 'icon', c.icon, 'name', c.name, 'description', c.description, 'href', c.href, 'click_event', c.click_event, 'iconForeground', c.iconforeground, 'iconBackground', c.iconbackground)))::jsonb AS js
           FROM (navigation_from_parents tree
             JOIN navigation c USING (code))
          WHERE ((tree.level > 0) AND (NOT ((tree.code)::text = ANY ((tree.parents)::text[]))))
          GROUP BY c.parent_code
        UNION ALL
         SELECT c.parent_code,
            ((((((((jsonb_build_object('code', c.code) || jsonb_build_object('icon', c.icon)) || jsonb_build_object('name', c.name)) || jsonb_build_object('description', c.description)) || jsonb_build_object('href', c.href)) || jsonb_build_object('click_event', c.click_event)) || jsonb_build_object('iconForeground', c.iconforeground)) || jsonb_build_object('iconBackground', c.iconbackground)) || jsonb_build_object('childern', tree.js)) AS js
           FROM (navigation_from_children tree
             JOIN navigation c ON (((c.code)::text = (tree.parent_code)::text)))
        )
 SELECT jsonb_agg(navigation_from_children.js) AS menuitems
   FROM navigation_from_children
  WHERE (navigation_from_children.parent_code IS NULL);

/*vw_column_info*/
CREATE VIEW vw_column_info (ordinal_position, column_name, table_schema, table_name, description, data_type, column_default, is_nullable, character_maximum_length, numeric_precision) AS  SELECT c.ordinal_position,
    c.column_name,
    c.table_schema,
    c.table_name,
    ( SELECT vw_meta_column.description
           FROM vw_meta_column
          WHERE ((vw_meta_column.column_name = (c.column_name)::name) AND (vw_meta_column.relname = (c.table_name)::name))) AS "description",
    c.data_type,
    c.column_default,
    c.is_nullable,
    c.character_maximum_length,
    c.numeric_precision
   FROM information_schema.columns c
  WHERE ((c.table_schema)::name = ANY (ARRAY['public'::name, 'auth'::name, 'storage'::name, 'pgsodium'::name, 'extensions'::name]))
  ORDER BY c.ordinal_position;


/*vw_tables_and_views*/

CREATE VIEW vw_tables_and_views (table_name, table_schema, table_catalog, object_type) AS  SELECT tables.table_name,
    tables.table_schema,
    tables.table_catalog,
    'TABLE'::text AS object_type
   FROM information_schema.tables
  WHERE (((tables.table_type)::text = 'BASE TABLE'::text) AND ((tables.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])))
UNION ALL
 SELECT views.table_name,
    views.table_schema,
    views.table_catalog,
    'VIEW'::text AS object_type
   FROM information_schema.views
  WHERE ((views.table_schema)::name <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name]));


/*get_parent_navigations*/

CREATE FUNCTION get_parent_navigations ()  RETURNS json
  VOLATILE
AS $body$
SELECT  
       json_agg(jsonb_build_object('is_active',c.is_active,'css_class',c.css_class,'sort_order',c.sort_order,'is_action_button',c.is_action_button,'nav_module_code',c.nav_module_code,'code',c.code,'parent_code',c.parent_code,'icon',c.icon,'name', c.NAME,'description', c.description,'href', c.href,'click_event', c.click_event,'iconForeground', c.iconForeground,'iconBackground', c.iconBackground)) ::jsonb AS js
FROM    navigation c
WHERE    c.parent_code is null and c.code not in (select distinct parent_code from navigation where parent_code is not null)
GROUP BY c.parent_code
$body$ LANGUAGE sql;

/*get_child_navigations*/

CREATE FUNCTION get_child_navigations ()  RETURNS json
  VOLATILE
AS $body$
WITH recursive navigation_from_parents AS
(
       -- Classes with no parent, our starting point
       SELECT code,
              NAME,
              css_class,
              sort_order,
              parent_code,
              nav_module_code,
              is_action_button,
              description,
              icon,
              is_active,
              href,
              click_event,
              iconforeground,
              iconbackground,
              is_footer_description,
              '{}'::varchar[] AS parents,
              0               AS level
       FROM   navigation
       WHERE  parent_code IS NULL
       UNION ALL
       -- Recursively find sub-classes and append them to the result-set
       SELECT c.code,
              c.NAME,
              c.css_class,
              c.sort_order,
              c.parent_code,
              c.nav_module_code,
              c.is_action_button,
              c.description,
              c.icon,
              c.is_active,
              c.href,
              c.click_event,
              c.iconforeground,
              c.iconbackground,
              c.is_footer_description,
              parents
                     || c.parent_code,
              level+1
       FROM   navigation_from_parents p
       JOIN   navigation c
       ON     c.parent_code = p.code
       WHERE  NOT c.code = ANY(parents)), navigation_from_children AS
(
         -- Now start from the leaf nodes and recurse to the top-level
         -- Leaf nodes are not parents (level > 0) and have no other row
         -- pointing to them as their parents, directly or indirectly
         -- (not id = any(parents))
         SELECT   c.parent_code,
                  --json_agg((c.name,c.href)) ::jsonb as js
                  json_agg(jsonb_build_object('is_footer_description',c.is_footer_description,'is_active',c.is_active,'code',c.code, 'css_class',c.css_class, 'sort_order',c.sort_order, 'parent_code',c.parent_code, 'nav_module_code',c.nav_module_code, 'is_action_button',c.is_action_button, 'parent_code',c.parent_code,'icon',c.icon,'name', c.NAME,'description', c.description,'href', c.href,'click_event', c.click_event,'iconForeground', c.iconforeground,'iconBackground', c.iconbackground)) ::jsonb AS js
         FROM     navigation_from_parents tree
         JOIN     navigation c
         using    (code)
         WHERE    level > 0
         AND      NOT code = ANY(parents)
         GROUP BY c.parent_code
         UNION ALL
         -- build our JSON document, one piece at a time
         -- as we're traversing our graph from the leaf nodes,
         -- the bottom-up traversal makes it possible to accumulate
         -- sub-classes as JSON document parts that we glue together
         SELECT c.parent_code,
                jsonb_build_object('code', c.code)
                       || jsonb_build_object('icon', c.icon)
                       || jsonb_build_object('css_class', c.css_class)
                       || jsonb_build_object('sort_order', c.sort_order)
                       || jsonb_build_object('parent_code', c.parent_code)
                       || jsonb_build_object('nav_module_code', c.nav_module_code)
                       || jsonb_build_object('is_action_button', c.is_action_button)
                       || jsonb_build_object('is_active', c.is_active)
                       || jsonb_build_object('name', c.NAME)
                       || jsonb_build_object('description', c.description)
                       || jsonb_build_object('href', c.href)
                       || jsonb_build_object('click_event', c.click_event)
                       || jsonb_build_object('iconForeground', c.iconforeground)
                       || jsonb_build_object('iconBackground', c.iconbackground)
                       || jsonb_build_object('is_footer_description', c.is_footer_description)
                       || jsonb_build_object('children', js) AS js
         FROM   navigation_from_children tree
         JOIN   navigation c
         ON     c.code = tree.parent_code )
-- Finally, the traversal being done, we can aggregate
-- the top-level classes all into the same JSON document,
-- an array.
SELECT jsonb_agg(js) AS menu
FROM   navigation_from_children
WHERE  parent_code IS NULL
$body$ LANGUAGE sql;


